<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTML Tilemap Editor</title>
    <style>
        body {
            font-family: sans-serif;
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
        }
        .control-panel, .editor-area {
            border: 1px solid #ccc;
            padding: 15px;
            border-radius: 5px;
            background-color: #f9f9f9;
        }
        .control-panel label, .control-panel input, .control-panel button {
            display: block;
            margin-bottom: 10px;
        }
        .control-panel input[type="number"] {
            width: 60px;
        }
         .control-panel div {
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px dashed #eee;
        }
         .control-panel div:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
         }

        .editor-area {
            display: flex;
            gap: 20px;
            align-items: flex-start; /* Align tops */
            width: 100%; /* Make editor area take full width */
        }

        #palette-container, #map-container {
            border: 1px solid #aaa;
            overflow: auto; /* Add scrollbars if content overflows */
            max-height: 600px; /* Limit height */
        }

        .palette-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 0;
            padding: 5px;
            background-color: #eee;
            font-size: 0.9em;
        }
        .palette-header h3 {
             margin: 0;
             padding: 0;
             text-align: left;
             flex-grow: 1; /* Allow title to take space */
        }
        #map-container h3 {
             margin-top: 0;
             padding: 5px;
             background-color: #eee;
             text-align: center;
             font-size: 0.9em;
        }


        canvas {
            display: block;
            border: 1px dashed #999;
            background-color: #fff;
            image-rendering: pixelated; /* Keep tiles sharp */
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }

        #palette-canvas {
            cursor: pointer;
        }
        #map-canvas {
            cursor: crosshair;
        }

        .selected-tile-highlight {
             outline: 3px solid red;
             outline-offset: -3px; /* Draw outline inside */
        }
        #status {
            width: 100%;
            margin-top: 10px;
            padding: 10px;
            background-color: #e0e0e0;
            border-radius: 3px;
            min-height: 1.2em;
            font-size: 0.9em;
        }
        /* Hide file input visually, but keep it accessible */
        #import-file-input {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap; /* added line */
            border: 0;
        }
        button {
             padding: 8px 15px;
             cursor: pointer;
             background-color: #007bff;
             color: white;
             border: none;
             border-radius: 4px;
             transition: background-color 0.2s;
             font-size: 0.9em; /* Slightly smaller button text */
             line-height: 1.2; /* Adjust line height */
        }
         button:hover {
             background-color: #0056b3;
         }
         button:disabled {
              background-color: #ccc;
              cursor: not-allowed;
         }
         #export-button, #import-button {
             margin-right: 10px;
         }
         #eraser-button {
             background-color: #6c757d; /* Grey color */
             padding: 5px 10px; /* Smaller padding */
         }
         #eraser-button:hover {
             background-color: #5a6268;
         }
         /* Style for the currently active tool (eraser or palette tile) */
         .active-tool {
             outline: 3px solid red;
             box-shadow: 0 0 5px rgba(255, 0, 0, 0.7);
         }

    </style>
</head>
<body>

    <div class="control-panel">
        <h2>Controls</h2>

        <div>
            <label for="spritesheet-upload">1. Upload Spritesheet:</label>
            <input type="file" id="spritesheet-upload" accept="image/*">
        </div>

        <div>
            <label for="tile-width">2. Tile Size (px):</label>
            Width: <input type="number" id="tile-width" value="16" min="1">
            Height: <input type="number" id="tile-height" value="16" min="1">
        </div>

        <div>
            <label for="map-width">3. Map Size (tiles):</label>
            Width: <input type="number" id="map-width" value="20" min="1">
            Height: <input type="number" id="map-height" value="15" min="1">
        </div>

        <div>
            <button id="load-button">4. Load Spritesheet / Create Map</button>
        </div>

        <div>
             <h3>Export / Import</h3>
             <button id="export-button" disabled>Export Map (JSON)</button>
             <button id="import-button">Import Map (JSON)</button>
             <input type="file" id="import-file-input" accept=".json">
             <p style="font-size: 0.8em; color: #555;">Note: Load a compatible spritesheet *before* importing map data.</p>
        </div>
    </div>

    <div class="editor-area">
        <div id="palette-container" style="display: none;">
             <div class="palette-header">
                <h3>Tileset Palette</h3>
                <button id="eraser-button">Eraser</button>
             </div>
             <canvas id="palette-canvas"></canvas>
        </div>

        <div id="map-container" style="display: none;">
             <h3>Map Canvas (Click or Drag to paint/erase)</h3>
             <canvas id="map-canvas"></canvas>
        </div>
    </div>

     <div id="status">Editor ready. Please load a spritesheet and define dimensions.</div>


    <script>
        // --- Global State ---
        const ERASER_MODE = -1; // Use -1 to indicate eraser/empty tile
        let spritesheetImage = null;
        let tileWidth = 0;
        let tileHeight = 0;
        let mapWidthInTiles = 0;
        let mapHeightInTiles = 0;
        let mapData = []; // 2D array storing tile index (or ERASER_MODE for empty)
        let selectedTileIndex = ERASER_MODE; // Start with eraser potentially? Or make it selectable. Let's default to nothing selected until clicked.
        let tilesPerRowInPalette = 0;
        let totalTilesInPalette = 0;
        let isPainting = false;

        // --- Canvas Elements & Contexts ---
        const paletteCanvas = document.getElementById('palette-canvas');
        const mapCanvas = document.getElementById('map-canvas');
        const paletteCtx = paletteCanvas.getContext('2d');
        const mapCtx = mapCanvas.getContext('2d');

        // --- DOM Elements ---
        const spritesheetUpload = document.getElementById('spritesheet-upload');
        const tileWidthInput = document.getElementById('tile-width');
        const tileHeightInput = document.getElementById('tile-height');
        const mapWidthInput = document.getElementById('map-width');
        const mapHeightInput = document.getElementById('map-height');
        const loadButton = document.getElementById('load-button');
        const exportButton = document.getElementById('export-button');
        const importButton = document.getElementById('import-button');
        const importFileInput = document.getElementById('import-file-input');
        const paletteContainer = document.getElementById('palette-container');
        const mapContainer = document.getElementById('map-container');
        const statusDiv = document.getElementById('status');
        const eraserButton = document.getElementById('eraser-button'); // Get eraser button

        // --- Initialization and Event Listeners ---
        window.onload = () => {
            updateStatus("Editor ready. Load spritesheet and set dimensions.");
            setCanvasPixelated(paletteCtx);
            setCanvasPixelated(mapCtx);
            selectedTileIndex = ERASER_MODE; // Default to eraser initially
            updateToolHighlight(); // Ensure eraser starts highlighted if it's the default
        };

        loadButton.addEventListener('click', loadSpritesheetAndMap);
        paletteCanvas.addEventListener('click', handlePaletteClick);
        eraserButton.addEventListener('click', selectEraser); // Add listener for eraser button
        mapCanvas.addEventListener('mousedown', startPainting);
        mapCanvas.addEventListener('mousemove', paintOnMap);
        mapCanvas.addEventListener('mouseup', stopPainting);
        mapCanvas.addEventListener('mouseleave', stopPainting);
        exportButton.addEventListener('click', exportMap);
        importButton.addEventListener('click', () => importFileInput.click());
        importFileInput.addEventListener('change', importMap);

        // --- Core Functions ---

        function setCanvasPixelated(ctx) {
             ctx.imageSmoothingEnabled = false;
        }

        function updateStatus(message) {
            statusDiv.textContent = message;
            console.log("Status:", message);
        }

        function updateToolHighlight() {
             // Remove highlight from eraser button
            eraserButton.classList.remove('active-tool');
             // Redraw palette handles removing/adding highlight on tiles
            drawPalette();

            // Add highlight to eraser button if it's selected
            if (selectedTileIndex === ERASER_MODE) {
                eraserButton.classList.add('active-tool');
            }
        }

        function loadSpritesheetAndMap() {
            const file = spritesheetUpload.files[0];
            tileWidth = parseInt(tileWidthInput.value, 10);
            tileHeight = parseInt(tileHeightInput.value, 10);
            mapWidthInTiles = parseInt(mapWidthInput.value, 10);
            mapHeightInTiles = parseInt(mapHeightInput.value, 10);

            if (!file) {
                updateStatus("Error: Please select a spritesheet image.");
                return;
            }
            if (isNaN(tileWidth) || tileWidth <= 0 || isNaN(tileHeight) || tileHeight <= 0) {
                updateStatus("Error: Please enter valid tile dimensions (positive numbers).");
                return;
            }
            if (isNaN(mapWidthInTiles) || mapWidthInTiles <= 0 || isNaN(mapHeightInTiles) || mapHeightInTiles <= 0) {
                updateStatus("Error: Please enter valid map dimensions (positive numbers).");
                return;
            }

            updateStatus("Loading spritesheet...");

            const reader = new FileReader();
            reader.onload = function(event) {
                spritesheetImage = new Image();
                spritesheetImage.onload = () => {
                    updateStatus("Spritesheet loaded. Initializing editor...");
                    initializeEditor();
                     exportButton.disabled = false;
                };
                spritesheetImage.onerror = () => {
                    updateStatus("Error: Could not load the image file. Ensure it's a valid image.");
                    spritesheetImage = null;
                     exportButton.disabled = true;
                     paletteContainer.style.display = 'none';
                     mapContainer.style.display = 'none';
                };
                spritesheetImage.src = event.target.result;
            }
            reader.onerror = () => {
                 updateStatus("Error: Could not read the selected file.");
                  exportButton.disabled = true;
            }
            reader.readAsDataURL(file);
        }

        function initializeEditor() {
            if (!spritesheetImage) {
                updateStatus("Error: Spritesheet image not available for initialization.");
                return;
            }

            if (spritesheetImage.width < tileWidth || spritesheetImage.height < tileHeight) {
                 updateStatus(`Error: Spritesheet dimensions (${spritesheetImage.width}x${spritesheetImage.height}) are smaller than tile dimensions (${tileWidth}x${tileHeight}).`);
                 exportButton.disabled = true;
                 paletteContainer.style.display = 'none';
                 mapContainer.style.display = 'none';
                 return;
            }

            tilesPerRowInPalette = Math.floor(spritesheetImage.width / tileWidth);
            const rowsInPalette = Math.floor(spritesheetImage.height / tileHeight);
            totalTilesInPalette = tilesPerRowInPalette * rowsInPalette;

            paletteCanvas.width = tilesPerRowInPalette * tileWidth;
            paletteCanvas.height = rowsInPalette * tileHeight;
            paletteContainer.style.display = 'block';

            mapCanvas.width = mapWidthInTiles * tileWidth;
            mapCanvas.height = mapHeightInTiles * tileHeight;
            mapContainer.style.display = 'block';

            if (mapData.length !== mapHeightInTiles || (mapData[0] && mapData[0].length !== mapWidthInTiles)) {
                console.log("Initializing new map data grid.");
                mapData = Array(mapHeightInTiles).fill(null).map(() => Array(mapWidthInTiles).fill(ERASER_MODE));
            } else {
                console.log("Keeping existing map data.");
            }

            // Reset selection to eraser when loading new map/spritesheet
            selectedTileIndex = ERASER_MODE;

            drawPalette();
            drawMap();
            updateToolHighlight(); // Make sure eraser is highlighted initially

            updateStatus(`Editor ready. Spritesheet: ${spritesheetImage.width}x${spritesheetImage.height}, Tiles: ${tileWidth}x${tileHeight}, Map: ${mapWidthInTiles}x${mapHeightInTiles}. Eraser selected.`);
        }


        function drawPalette() {
             if (!spritesheetImage || !paletteCtx) return;

             setCanvasPixelated(paletteCtx);
             paletteCtx.clearRect(0, 0, paletteCanvas.width, paletteCanvas.height);

             let tileIndex = 0;
             const rows = Math.floor(spritesheetImage.height / tileHeight);

             for (let r = 0; r < rows; r++) {
                 for (let c = 0; c < tilesPerRowInPalette; c++) {
                     const sx = c * tileWidth;
                     const sy = r * tileHeight;
                     const dx = c * tileWidth;
                     const dy = r * tileHeight;

                     // Only draw if the image dimensions allow this tile fully
                     if (sx + tileWidth <= spritesheetImage.width && sy + tileHeight <= spritesheetImage.height) {
                         paletteCtx.drawImage(
                             spritesheetImage,
                             sx, sy, tileWidth, tileHeight,
                             dx, dy, tileWidth, tileHeight
                         );

                         // Highlight selected tile (only if not in eraser mode)
                         if (tileIndex === selectedTileIndex && selectedTileIndex !== ERASER_MODE) {
                             paletteCtx.strokeStyle = 'red';
                             paletteCtx.lineWidth = 2;
                             // Add the highlight class effect via drawing equivalent
                             paletteCtx.strokeRect(dx + 1.5, dy + 1.5, tileWidth - 3, tileHeight - 3); // Adjusted for line width
                         }
                         tileIndex++;
                     } else {
                        // Optionally draw something for incomplete tiles or just skip
                        console.warn(`Skipping incomplete tile draw at palette row ${r}, col ${c}`);
                        // Increment tileIndex even for skipped partial tiles if needed,
                        // but it's safer to calculate totalTiles based on full tiles only.
                        // Adjust totalTilesInPalette calculation if needed.
                        tileIndex++; // Assuming we still count it conceptually
                     }
                 }
             }
             // Recalculate based on actual drawable tiles if necessary
             // totalTilesInPalette = tileIndex; // If partial tiles shouldn't be counted
        }


        function drawMap() {
             if (!mapCtx || !spritesheetImage || mapData.length === 0) return;

             setCanvasPixelated(mapCtx);
             mapCtx.clearRect(0, 0, mapCanvas.width, mapCanvas.height);

             for (let r = 0; r < mapHeightInTiles; r++) {
                 for (let c = 0; c < mapWidthInTiles; c++) {
                    drawMapTile(c, r);
                 }
             }
        }

        function drawMapTile(mapX, mapY) {
            if (!mapCtx || mapX < 0 || mapX >= mapWidthInTiles || mapY < 0 || mapY >= mapHeightInTiles) {
                 return; // Out of bounds
            }

            const tileIndex = mapData[mapY][mapX];
            const destX = mapX * tileWidth;
            const destY = mapY * tileHeight;

            mapCtx.clearRect(destX, destY, tileWidth, tileHeight); // Clear the cell

            // Draw only if it's not an empty/erased tile and the spritesheet is loaded
            if (tileIndex !== ERASER_MODE && spritesheetImage && tileIndex < totalTilesInPalette) {
                const tileCol = tileIndex % tilesPerRowInPalette;
                const tileRow = Math.floor(tileIndex / tilesPerRowInPalette);

                const sourceX = tileCol * tileWidth;
                const sourceY = tileRow * tileHeight;

                 // Add extra check for safety, ensure source rect is within spritesheet
                 if (sourceX + tileWidth <= spritesheetImage.width && sourceY + tileHeight <= spritesheetImage.height) {
                    try {
                        mapCtx.drawImage(
                            spritesheetImage,
                            sourceX, sourceY, tileWidth, tileHeight,
                            destX, destY, tileWidth, tileHeight
                        );
                    } catch (e) {
                        console.error(`Error drawing tile index ${tileIndex} at map[${mapY}][${mapX}]:`, e);
                        mapCtx.fillStyle = 'magenta';
                        mapCtx.fillRect(destX, destY, tileWidth, tileHeight);
                    }
                 } else {
                    console.warn(`Source tile ${tileIndex} (at ${sourceX},${sourceY}) out of bounds for spritesheet.`);
                    // Draw error or leave blank
                    mapCtx.fillStyle = 'orange'; // Indicate source error
                    mapCtx.fillRect(destX, destY, tileWidth, tileHeight);
                 }
            }
        }


        // --- Event Handlers ---

        function handlePaletteClick(event) {
             if (!spritesheetImage) return;

             const rect = paletteCanvas.getBoundingClientRect();
             const scaleX = paletteCanvas.width / rect.width;
             const scaleY = paletteCanvas.height / rect.height;

             const x = (event.clientX - rect.left) * scaleX;
             const y = (event.clientY - rect.top) * scaleY;

             const tileCol = Math.floor(x / tileWidth);
             const tileRow = Math.floor(y / tileHeight);

             // Ensure click is within the bounds of the drawn palette area
             if (tileCol >= 0 && tileCol < tilesPerRowInPalette && tileRow >= 0 && tileRow < Math.ceil(totalTilesInPalette / tilesPerRowInPalette)) {
                 const clickedIndex = tileRow * tilesPerRowInPalette + tileCol;

                 // Ensure the calculated index is actually a valid, fully drawn tile
                 if (clickedIndex >= 0 && clickedIndex < totalTilesInPalette) {
                     selectedTileIndex = clickedIndex;
                     updateStatus(`Selected tile index: ${selectedTileIndex}`);
                     updateToolHighlight();
                 } else {
                      console.log("Clicked on palette, but outside valid tile index range:", clickedIndex);
                      // Optionally select eraser or do nothing
                      // selectEraser();
                 }
             } else {
                 console.log("Clicked outside palette grid bounds.");
             }
        }

        function selectEraser() {
            selectedTileIndex = ERASER_MODE;
            updateStatus("Eraser selected.");
            updateToolHighlight();
        }

         function getMapTileCoords(event) {
            if (!mapCanvas) return null;
             const rect = mapCanvas.getBoundingClientRect();
             const scaleX = mapCanvas.width / rect.width;
             const scaleY = mapCanvas.height / rect.height;

             const x = (event.clientX - rect.left) * scaleX;
             const y = (event.clientY - rect.top) * scaleY;

             const mapX = Math.floor(x / tileWidth);
             const mapY = Math.floor(y / tileHeight);

            if (mapX >= 0 && mapX < mapWidthInTiles && mapY >= 0 && mapY < mapHeightInTiles) {
                 return { mapX, mapY };
            }
            return null;
         }


        function startPainting(event) {
            if (event.button !== 0 || !spritesheetImage) return; // Only left click, require loaded sheet
            isPainting = true;
            paintOnMap(event); // Paint immediately on click
        }

        function paintOnMap(event) {
            if (!isPainting) return;

            const coords = getMapTileCoords(event);
            if (coords) {
                const { mapX, mapY } = coords;
                const currentTile = mapData[mapY][mapX];

                // Only update and redraw if the tile will change
                if (currentTile !== selectedTileIndex) {
                    mapData[mapY][mapX] = selectedTileIndex; // Place selected tile or eraser (-1)
                    drawMapTile(mapX, mapY); // Redraw just the affected tile

                    // Optional: Update status (can be spammy)
                    // if (selectedTileIndex === ERASER_MODE) {
                    //     updateStatus(`Erased tile at [${mapX}, ${mapY}]`);
                    // } else {
                    //     updateStatus(`Painted tile ${selectedTileIndex} at [${mapX}, ${mapY}]`);
                    // }
                }
            }
        }

        function stopPainting() {
            isPainting = false;
        }


        // --- Export / Import ---

        function exportMap() {
             if (!mapData || mapData.length === 0) {
                 updateStatus("Error: No map data to export.");
                 return;
             }

            const exportData = {
                tileWidth: tileWidth,
                tileHeight: tileHeight,
                mapWidthInTiles: mapWidthInTiles,
                mapHeightInTiles: mapHeightInTiles,
                mapData: mapData,
            };

            const jsonString = JSON.stringify(exportData, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);

            const a = document.createElement('a');
            a.href = url;
            a.download = 'map.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            updateStatus(`Map exported as map.json (${mapWidthInTiles}x${mapHeightInTiles} tiles).`);
        }

        function importMap(event) {
             const file = event.target.files[0];
             if (!file) {
                 updateStatus("Import cancelled or no file selected.");
                 return;
             }

             updateStatus("Importing map data...");
             const reader = new FileReader();

             reader.onload = (e) => {
                 try {
                     const importedData = JSON.parse(e.target.result);

                     if (typeof importedData.tileWidth !== 'number' ||
                         typeof importedData.tileHeight !== 'number' ||
                         typeof importedData.mapWidthInTiles !== 'number' ||
                         typeof importedData.mapHeightInTiles !== 'number' ||
                         !Array.isArray(importedData.mapData) ||
                         (importedData.mapData.length > 0 && !Array.isArray(importedData.mapData[0])) ) // Allow empty mapData array
                     {
                         throw new Error("Invalid or incomplete JSON structure.");
                     }

                     tileWidthInput.value = importedData.tileWidth;
                     tileHeightInput.value = importedData.tileHeight;
                     mapWidthInput.value = importedData.mapWidthInTiles;
                     mapHeightInput.value = importedData.mapHeightInTiles;

                     tileWidth = importedData.tileWidth;
                     tileHeight = importedData.tileHeight;
                     mapWidthInTiles = importedData.mapWidthInTiles;
                     mapHeightInTiles = importedData.mapHeightInTiles;
                     mapData = importedData.mapData; // Assign imported map data

                     updateStatus("Map data imported successfully. Verifying dimensions...");

                    // Validation: Check consistency between header dimensions and mapData array size
                    if (mapData.length !== mapHeightInTiles || (mapData.length > 0 && mapData[0].length !== mapWidthInTiles)) {
                         console.warn("Imported mapData dimensions mismatch header. Map might draw incorrectly. Using header dimensions for canvas.");
                         updateStatus("Warning: Imported map data size mismatch. Using header dimensions.");
                         // Optional: Attempt to resize/pad mapData or just proceed, drawing will clip/miss data.
                    }

                     if (spritesheetImage) {
                        updateStatus("Spritesheet already loaded. Re-initializing editor with imported dimensions...");
                         initializeEditor(); // Re-runs setup and draws imported map
                     } else {
                         updateStatus("Map data imported. Please load a compatible spritesheet and click 'Load/Create' to view.");
                         paletteCtx.clearRect(0, 0, paletteCanvas.width, paletteCanvas.height);
                         mapCtx.clearRect(0, 0, mapCanvas.width, mapCanvas.height);
                         paletteContainer.style.display = 'none';
                         mapContainer.style.display = 'none';
                         exportButton.disabled = true;
                         // Ensure eraser is selected visually even if map not shown yet
                         selectedTileIndex = ERASER_MODE;
                         updateToolHighlight();
                     }

                 } catch (error) {
                     updateStatus(`Error importing map: ${error.message}`);
                     console.error("Import Error:", error);
                 } finally {
                    event.target.value = null; // Reset input
                 }
             };

             reader.onerror = () => {
                 updateStatus("Error reading the import file.");
                  event.target.value = null;
             };

             reader.readAsText(file);
        }

    </script>

</body>
</html>